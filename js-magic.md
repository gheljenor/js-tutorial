[TOC]

# Магия javascript

Каждый язык программирования имеет свои особенности и javascript не исключение. Попробую описать основные из них.

## Магия типов

Во-первых в javascript есть всего несколько примитивных типов:

  - **`String`** - строка
  - **`Number`** - число
  - **`Boolean`** - значение true или false
  - **`Object`** - объект. Является родительским классом практически для всех сущностей.
  - **`Function`** - функция/конструктор класса. Вообще говоря функции являются потомками объектов, но из-за их сильной специфики я решил записать их в этот список.

Примитивные типы `String`, `Number`, `Boolean` могут также быть представлены в виде объектов. На практике такие объекты непосредственно обычно никто не создаёт - это происходит автоматически каждый раз, при обращении к свойствам и методам данных типов. Для получения примитивных значений из данных объектов используется метод `valueOf`.

Также отдельно можно упомянуть про некоторые стандартные значения:

  - **`undefined`** - это значение не принадлежащее ни к одному из типов. Оно присваивается переменной, которая не была инциализирована, а также возвращается функцией которая ничего не возвращает.
  - **`null`** - специальный значение для описания "пустоты". Применяется с той же целью что и `undefined`, но в случаях когда надо показать, что это не просто неопределённая переменная, а специально выставленное значение.
  - **`NaN`** - специальное числовое значение, который означает некорректные данные. Например NaN будет получен, если попытаться вычислить `parseInt("abcd")`
  - **`Infinity`** - ещё одно числовое значение описывающее бесконечное число. В основном получается в результате деления на ноль. Кстати этот тип имеет знак: `1/0; // Infinity`, и `-1/0; // -Infinity`.

### Проверка типов

Для проверки типа целая куча разных конструкций: `instanceof`, `typeof`, `Array.isArray`, `isFinite`, `isNaN`. Какой из методов использовать зависит от конкретной ситуации. Поясню на примере:

#### typeof

```javascript
typeof "111"; // "string"
typeof String("111"); // "string"
typeof new String("111"); // "object"

typeof 111; // "number"
typeof Number(111); // "number"
typeof new Number(111); // "object"

typeof true; // "boolean"
typeof Boolean(true); // "boolean"
typeof new Boolean(true); // "object"

typeof function(){}; // "function"

typeof new Array(); // "object"
typeof new Object(); // "object"
typeof new RegExp(); // "object"

typeof null; // "object"
typeof undefined; // "undefined"

typeof NaN; // "number"
typeof Infinity; // "number"
```

#### instanceof

```javascript
"123" instanceof String; // false
String("123") instanceof String; // false
new String("123") instanceof String; // true

123 instanceof Number; // false
Number(123) instanceof Number; // false
new Number(123) instanceof Number; // true

true instanceof Boolean; // false
Boolean(true) instanceof Boolean; // false
new Boolean(true) instanceof Boolean; // true

(function(){}) instanceof Function; // true
(function(){}) instanceof Object; // true

new Array() instanceof Array; // true
new Array() instanceof Object; // true

new Object() instanceof Object; // true

new RegExp() instanceof RegExp; // true
new RegExp() instanceof Object; // true

null instanceof Object; // false
undefined instanceof Object; // false

NaN instanceof Object; // false
NaN instanceof Number; // false

Infinity instanceof Object; // false
Infinity instanceof Number; // false
```

> **Совет.** Хотя в большинстве случаев проверка `instanceof Array` будет работать корректно, лучше использовать специальный метод `Array.isArray`. Дело в том как браузер работает с несколькими окнами в т.ч. `<iframe>`  - в каждом окне существует своя копия класса `Array`. При передаче значения между окнами возможна ситуация при которой простая проверка `array instanceof Array` выдаст `false`, т.к. у массива в другом окне другой конструктор. Именно для таких случаев используется метод `Array.isArray` - он позволяет надёжно проверить, что объект является массивом вне зависимости от его происхождения.

Когда мы делаем проверки на то, что в переменной число, обычно нас интересует наличие адекватного значения с которым можно работать, т.е. значения `NaN` и `Infinite` нас редко интересуют. К тому же часто бывает необходимо проверить, что в строковой переменной содержится число. Для этих целей есть специальные проверки:

#### isNaN

```javascript
NaN == NaN; // false
isNaN(NaN); // true
isNaN("NaN"); // true
isNaN(123); // false
isNaN("123"); // false
isNaN(Infinity); // false
isNaN("Infinity"); // false
isNaN("asdf"); // true
```
#### isFinite

```javascript
Infinity == Infinity; // true
isFinite(NaN); // false
isFinite("NaN"); // false
isFinite(123); // true
isFinite("123"); // true
isFinite(Infinity); // false
isFinite("Infinity"); // false
isFinite("adsf"); // false
```

### Приведение типов

Приведение типов бывает либо автоматическим, либо непосредственным. Непосредственное приведение типов выполняется с помощью специальных методов или с помощью вызова конструктора:

```javascript
(123).toString(); // "123"
String(123); // "123"

parseInt("123"); // 123
parseFloat("123.45"); // 123.45
Number("123.45"); // 123.45

Boolean(1); // true
Boolean(0); // false
```

Отдельно стоит упомянуть про создание объектов-обёрток для примитивных типов:

```javascript
Object(1) instanceof Number; // true
new Object(1) instanceof Number; // true
Number(1) instanceof Number; // false - данный метод возвращает примитивный тип, а не объект
new Number(1) instanceof Number; // true

Object("asdf") instanceof String; // true
new Object("asdf") instanceof String; // true
String("asdf") instanceof String; // false - данный метод возвращает примитивный тип, а не объект
new String("asdf") instanceof String; // true

Object(true) instanceof Boolean; // true
new Object(true) instanceof Boolean; // true
Boolean(true) instanceof Boolean; //  false - данный метод возвращает примитивный тип, а не объект
new Boolean(true) instanceof Boolean; // true
```

Автоматическое приведение типов происходит в целом ряде случаев:

  - **унарные операторы + и -** - значение приводится к типу `Number`
  - **операторы конкатенации + и +=** - если слева стоит значение типа `String`, то значение справа приводится к типу `String`, в противном случае эти операторы трактуются как арифметические.
  - **арифметические операторы +, -, \*, /, %, +=, -=, \*=, /=** - перед вычислением данные приводятся к типу `Number`
  - **побитовые операторы ~, &, |, ^, \<\<, \>\>, \>\>\>, &=, |=, ^=, \<\<=, \>\>=, \>\>\>=** - перед вычислением данные приводятся к типу `Number`
  - **унарные операторы ++ и --** - перед вычислением значения данные приводятся к типу `Number`
  - **операторы сравнение ==, !=** - перед проведением сравнения тип справа приводится к типу слева: `1 == "1"; // true`
  - **операторы сравнения >, <, >=, <=** - если данные с обоих сторон не относятся к типу `String`, то они приводятся к типу `Number`, в противном случае проиходит лексикографическое сравнение.
  - **оператор отрицания !** - перед вычислением итогового значения тип переменной приводится к `Boolean`.
  - **операторы || и &&** - перед вычислением значения данные слева приводятся к типу `Boolean`. Про эти операторы чуть позже будет рассказано отдельно.
  - **условия в блоках `if`, `while`, `do`, `for`, а также в тренарных операторах** - данные приводятся к типу `Boolean`
  - во многих других случаях, когда требуются данные одного типа, а предоставлены данные другого

> **Совет.** При использовании оператора `+` всегда ставьте числовой литерал или математическую операцию на первое место, чтобы избежать случайной конкатенации вместо сложения. Например лучше делать `a = 1 + b`, а не `a = b + 1` или `a = b * c + d` вместо `a = d + b * c`.

В случае с операторами `||` и `&&` приведение типов работает очень специфично. Наиболее точно можно переписать работу этих операторов в тренарной форме:

```javascript
// a || b
Boolean(a) == true ? a : b;

// a && b
Boolean(a) == true ? b : a;
```

Т.е. возвращаемое значение всегда имеет тот же тип, что и один из аргуметов и проверка на истину происходит только для первого аргумента.

Сразу стоит заметить, что автоматическое приведение типов не происходит в случае использования операторов сравнения `===` и `!==`. Менее очевидными случаями являются сравнения, в блоке `switch`, а также в методе `indexOf`.

#### Boolean

Порой бывает не совсем очевидно каким образом различные значения приводятся к типу `Boolean`. Тут простое правило, есть короткий список данных которые интерпретируются как `false`, все остальные значения интерпретируются как `true`

```javascript
Boolean(); // false
Boolean(0); // false
Boolean(""); // false
Boolean(null); // false
Boolean(NaN); // false
Boolean(undefined); // false
```

#### Number

Приведение к типу `Number` происходит несколько сложнее:

```javascript
Number(); // 0
Number(undefined); // NaN
Number(null); // NaN
Number([]); // 0
Number([undefined]); // 0
Number([singleValue]); // Number(singleValue)
Number([1, 2]); // NaN
Number(object); // Number(object.valueOf())
Number(true); // 1
Number(false); // 0
Number(string); // parseFloat(string)
```

Тут стоит присмотреться ко строкам 2, 5 и 6 - `Number(undefined) = NaN`, `Number([singleValue]) = Number(singleValue)` и `Number([undefined]) = 0`. В данном случае правило 5 противоречит правилам 2 и 6, что может приводить к различным ошибкам, если рассчитывать на приведение типов в случае, когда данные находятся в массиве.

> **Совет.** Если требуется вызвать некий метод класса `Number` при задании литерала, то для целого числа следует использовать `..`, а для дробного `.`, например: `123..toString(8)`, `123.4567.toFixed(2)`. Но лучше использовать скобки и всегда обращаться через `.`: `(123).toString(8)`, `(123.4567).toFixed(2)`

#### String

Приведение к типу `String` происходит путём вызова метода `toString`. Если данный метод отсутствует, будет брошено исключение `TypeError`.

## Магия прототипов

В отличие от множества других объектно-ориентированных языков программирования в javascript'е используется не классовое наследование, а прототипное. Это является камнем преткновения для множества разработчиков, хотя на самом деле всё очень просто. Если описывать этот трюк в двух словах, то у каждого объекта есть некий прототип - это тоже объект с некоторыми свойствами. Когда мы пытаемся получить доступ к свойству объекта, сначала оно ищется в списке собственных свойств объекта, если оно не найдено, то далее идёт попытка найти это свойство у прототипа, далее у его прототипа и т.д. Всё почти как с классами, но т.к. в качестве родителя в данном случае используется не класс, а объект, то появляются некоторые особенности:

 - класс является всего лишь шаблоном-описанием и хранилищем статический свойств
 - прототип является полноценным объектом, свойства которого доступны сами по себе, а не только через экземпляры класса
 - описание класса обычно нельзя изменять "налету"
 - описание прототипа можно как угодно изменять "налету" - можно добавлять, перезаписывать и удалять любые свойства
 - классы как правило объявляются заранее
 - прототипы всегда создаются уже в рантайме, как и любые другие объекты (исключением являются только встроенные объекты)

Может несколько смущать сам синтаксис описания прототипов и конструкторов. Особенно если делать всё по-уму.

```javascript
var ClassName = function(...) {
    // Инициализация супер-класса
    SuperClass.apply(this, arguments);

    // Здесь происходит инициализация текущего класса
};

ClassName.prototype = (function() {
    // Нам не нужно вызывать конструктор родительского класса при создании прототипа,
    // так что создадим временный класс с пустым конструктором и тем же прототипом
    var SuperClassPrototype = function() {};
    SuperClassPrototype.prototype = SuperClass.prototype;

    return new SuperClassPrototype();
})();

// Добавляем дополнительные свойства в прототип
ClassName.prototype.someMethod = function() {
 ...
};
```

Тут есть целый ряд смущающих моментов:

  1. вместо привычного ключевого слова `class` мы просто объявляем функцию, которая выполняет роль конструктора.
  2. вторых конструкция которая создаёт прототип, наследуя его от родительского "класса" выглядит вообще загадочно и непонятно на первый взгляд
  3. инициализация родительского класса тоже выглядит не совсем понятно

Разберёмся с каждым пунктом отдельно. С отсутствием ключевого слова `class` придётся смириться. Чтобы отличать "классы" от функций стоит использовать правило именования. "Классы" должны начинаться с заглавной буквы, функции и методы - со строчной.

С наследованием несколько сложнее. Во-первых следует понимать то как работает `instanceof`. Проверка на принадлежность "классу" происходит путём поиска в цепочке прототипов объекта свойства `prototype` указанного конструктора. При этом сам конструктор никак не учитывается.

```javascript
var prototype = {};

var ClassA = function() {};
ClassA.prototype = prototype;

var ClassB = function() {};
ClassB.prototype = prototype;

var obj = new ClassA();

obj instanceof ClassA; // true
obj instanceof ClassB; // true
```

Далее стоит разобраться с конструкцией `(function() { return ... })()`. Эта конструкция объявляет функцию, тут же вызывает её и подставляет возвращаемое значение на место данной конструкции. Для этого даже придумали аббревиатуру **IIFE** - immediately invoked function expression, если переводить дословно - немедленно вызываемое функциональное выражение.

Теперь разберёмся с данной конструкцией детально. Для организации наследования нам нужно, чтобы у прототипа текущего "класса" прототипом являлся объект класса-родителя. Однако стоит помнить, что в конструкторе могут объявляться различные свойства и в общем случае нам нужно, чтобы эти свойства оставались свойствами экземпляра, а не прототипа. Так что следует избежать вызова конструктора родительского "класса", поэтому мы создаём промежуточный "класс" с пустым конструктором и тем же прототипом, что у родительского "класса".

Насчёт инициализации родительского "класса" пока что скажу только то, что для этого требуется вызвать конструктор данного "класса" с контекстом текущего экземпляра объекта и нужными аргументами. Об этих возможностях будет рассказано позднее более подробно. В данном коде мы вызываем конструктор родительского "класса" с теми же аргументами, с которыми был вызван конструктор текущего класса.
